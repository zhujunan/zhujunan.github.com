Python笔记
==========

# 目录

[Python基本语法](#Python基本语法)

[流程控制语句](#流程控制语句)

[基础数据类型](#基础数据类型)

[序列](#序列)

[函数](#函数)

[对象](#对象)

[异常和文件](#异常和文件)


# Python基本语法

    1.在Python中严格区分大小写
    2.Python中的每一行就是一条语句，每条语句以换行结束
    3.一条语句可以分多行编写，多行编写时语句后边以\结尾  
    4.Python是缩进严格的语言，所以在Python中不要随便写缩进  
    5.在Python中使用#来表示注释，#后的内容都属于注释，注释的内容将会被解释器所忽略

## 变量和标识符

    使用变量不用声明，可以直接赋值.
    标识符中可以有字母,数字,_,但是不能以数字开头.
    python中的标识符是区分大小写的
    
## 类型检查

    type() 方法:
    type(name, bases, dict),其中name是类的名称,bases是基类的元组,dict是类内定义的命名空间变量.
    当有一个参数时它的返回值是对象类型,有三个参数时,返回值是新的类型对象.

    isinstance() 方法:
    isinstance(object, classinfo),其中object 是实例对象,变量classinfo可以是直接或间接类名,
    基本类型或者由它们组成的元组（如tuple,dict,int,str,float,list,set,bool,class类等）.
    如果对象的类型与classinfo相同则返回值为True，否则返回值为 False。

    两者的区别：
    在判断子类上这两个函数不一样.type()不会认为子类是父类的类型,不考虑继承关系.isinstance()会认为子类是父类的类型,考虑继承关系.
    
## 用户交互

    input():
    input(str),打印str，同时接收并返回输入的值作为字符串保存
    
## 解构

    a,b,c = [1,2,3]
    
## 复制

    = 只能复制地址
    .copy()可以产生新的数据
    
## is 和 == 的区别

    == 判断内容
    is 判断地址

## 对象（object）

## 对象的结构
    - 每个对象中都要保存三种数据
        - id（标识）
            > id用来标识对象的唯一性，每一个对象都有唯一的id
            > 对象的id就相当于人的身份证号一样
            > 可以通过id()函数来查看对象的id
            > id是由解析器生成的，在CPython中，id就是对象的内存地址
            > 对象一旦创建，则它的id永远不能再改变

        - type（类型）
            > 类型用来标识当前对象所属的类型
            > 比如：int str float bool 。。。
            > 类型决定了对象有哪些功能
            > 通过type()函数来查看对象的类型
            > Python是一门强类型的语言，对象一旦创建类型便不能修改

        - value（值）
            > 值就是对象中存储的具体的数据
            > 对于有些对象值是可以改变的
            > 对象分成两大类，可变对象 不可变对象
                可变对象的值可以改变
                不可变对象的值不能改变

## 变量和对象

    - 对象并没有直接存储到变量中，在Python中变量更像是给对象起了一个别名
    - 变量中存储的不是对象的值，而是对象的id（内存地址），
        当我们使用变量时，实际上就是在通过对象id在查找对象
    - 变量中保存的对象，只有在为变量重新赋值时才会改变
    - 变量和变量之间是相互独立的，修改一个变量不会影响另一个变量

## 类型转换

    - 所谓的类型转换，将一个类型的对象转换为其他对象
    - 类型转换不是改变对象本身的类型，而是根据当前对象的值创建一个新对象
    用法:新类型名称(对象)

## 运算符(操作符)

1.算术运算符

    %   取余
    **  幂运算
    //  取商的整数
    
2.赋值运算符     +=...

3.比较运算符（关系运算符） True/False

4.逻辑运算符     not/and/or (有先后顺序)

5.成员运算     '...' in str/not in...

6.条件运算符（三元运算符） 

7.数据类型

    可以用交、并、差运算  & | -

# 流程控制语句

## 条件判断语句（if语句）

    if 判断条件:
        代码块
    
    if 判断条件: 一句代码
    
    if 判断条件1:
        代码块1
    elif 判断条件2:
        代码块2
    ...
    elif 判断条件n:
        代码块n
    else:
        默认代码块

## 循环语句
  
*while循环:

    while 判断条件:
        代码块
        
    while 判断条件:
        代码块
    else:
        代码块

*for循环

    for 临时变量 in 可迭代对象（数值，数组等）:
        代码块
        
    for...else

# 基础数据类型

## bytes类型

    字符串unicode
    在内存中用utf-8代替unicode储存字符串,另gbk
    str2 = str1.encode("utf-8")     
    得到str2 = b'\xe4\xb8\...' bytes类型
    解码:decode
    
## 字符串的格式化

    旧的方法 : str="...%s...%s..."%(数据1,数据2,...)%s填充字符串 %d填充数字 %f小数
    新的方案 : f-string str=f"..."  且 %s换为{数据1}

## 常用函数

常用函数|含义
--|--
upper()|
strip()|去掉两侧空白
replace()|
split()|
startwith()|判断是否以...开头
find()|
cout()|
isdigit()|判断是否纯数字
join()|列表组合成字符串
    
## 索引

    类似于c语言的字符数组
    str[0]   str[-1]倒数第一个字

## 切片

    str[start:end] 从 start 取到 end-1
    str[start:end:步长] 步长可以为负数

## 迭代

    for (定义)变量 in 可迭代对象:
        语句
        
# 序列

## 列表（list）

    lst = ["","",...]

- 增加数据

    ListName.append("...")   直接追加
    
    ListName.insert(n,"...") 在n处插入
    
    ListName.extend("list")  迭代新增
    
-  删除数据
   
   delectd = ListName.pop() 删除最后一个,返回值是删除部分
   
   ListName.pop(n) 删除第n个注意开头是0
   
   ListName.remove("") 删除指定元素
   
   ListName.clear() 清空
   
   del ListName[1:3] 切片删除

    
- 列表的索引规则和字符串一样

    list[index] = value     修改数据
    
    list[1:4:3] = value     步长为3

- 列表查询同字符串

- 其它操作

    ListName.court()    查询出现的次数
    
    ListName.sort()    排序，默认升序
    
    ListName.sort(reverse=True) 降序
    
    ListName.reverse() 倒过来
    
    len(ListName)
    
    
## 元组(tuple)

    只能看不能改的列表
    tuple(...)

## 序列（sequence）

    - 序列的分类：
        可变序列（序列中的元素可以改变）：
            > 列表（list）
        不可变序列（序列中的元素不能改变）：
            > 字符串（str）    
            > 元组（tuple）
        
## 可变对象

    - 每个对象中都保存了三个数据：
        id（标识）
        type（类型）
        value（值）    

    - 列表就是一个可变对象
        a = [1,2,3]

    - a[0] = 10 （改对象）
        - 这个操作是在通过变量去修改对象的值
        - 这种操作不会改变变量所指向的对象    
        - 当我们去修改对象时，如果有其他变量也指向了该对象，则修改也会在其他的变量中体现

    - a = [4,5,6] （改变量）
        - 这个操作是在给变量重新赋值
        - 这种操作会改变变量所指向的对象
        - 为一个变量重新赋值时，不会影响其他的变量

    - 一般只有在为变量赋值时才是修改变量，其余的都是修改对象

## 字典（dict）

    - 字典属于一种新的数据结构，称为映射（mapping）
    - 在字典中每一个元素都有一个唯一的名字，通过这个唯一的名字可以快速的查找到指定的元素
    - 在字典中可以保存多个对象，每个对象都会有一个唯一的名字
        这个唯一的名字，我们称其为键（key），通过key可以快速的查询value
        所以字典，我们也称为叫做键值对（key-value）结构
        每个字典中都可以有多个键值对，而每一个键值对我们称其为一项（item）
        
语法: 

    {key1:value1,...} key可哈希即不可变,不能用列表
    调用 DictName[key1]
    DictName.keys()
    DictName.values()
    DictName.items()

      
操作:

- 添加

    DictName["key1"] = "value1" 若没有,则创建
    
    DictName.setdefault("...","...") 同上,会返回value
    
- 修改

    DictName["key1"] = "value1"
    
- 删除

    DictName.pop("key1")  返回删除的值
    
    del DictName["key1"]
    
    DictName.popitem()
    
    DictName.clear()
    
- 查询

    DictName["key1"]
    
    DictName.get("key1")


## 集合（set）

- 集合用法和列表非常相似

- 不同点：

    1.集合中只能存储不可变对象
        
    2.集合中存储的对象是无序（不是按照元素的插入顺序保存）
        
    3.集合中不能出现重复的元素
        

# 函数

- 创建函数：

        def 函数名(...):
            代码块

- 调用函数：

        函数对象()
        返回值:return
        
- 动态传参
    
        * 动态接收位置参数
          FunctionName("","",...)
          会自动打包成元组
      
        ** 动态接收关键字参数
           FunctionName(""="",""="",...)
           自动打包成字典
        
        混合参数先位置,再关键字
        位置参数  *args  默认值参数  **kwargs
        
        

## 函数式编程

    - 在Python中，函数是一等对象
    - 一等对象一般都会具有如下特点：
        ① 对象是在运行时创建的
        ② 能赋值给变量或作为数据结构中的元素
        ③ 能作为参数传递
        ④ 能作为返回值返回
        
    - 高阶函数
        - 高阶函数至少要符合以下两个特点中的一个
          ① 接收一个或多个函数作为参数
          ② 将函数作为返回值返回 

    - 装饰器        

# 对象

## 面向对象（oop）
    - Python是一门面向对象的编程语言

## 类(class) 



## 类的定义


## 创建对象的流程

    p1 = Person()的运行流程
        1.创建一个变量
        2.在内存中创建一个新对象
        3.__init__(self)方法执行
        4.将对象的id赋值给变量

## 类的基本结构   

    class 类名([父类]) :

        公共的属性... 

        # 对象的初始化方法
        def __init__(self,...):
            ...

        # 其他的方法    
        def method_1(self,...):
            ...

        def method_2(self,...):
            ...

        ...    



# 异常和文件

## 异常
    程序在运行过程当中，不可避免的会出现一些错误，比如：
        使用了没有赋值过的变量
        使用了不存在的索引
        除0
        ...
    这些错误在程序中，我们称其为异常。
    程序运行过程中，一旦出现异常将会导致程序立即终止，异常以后的代码全部都不会执行！    

## 处理异常
    程序运行时出现异常，目的并不是让我们的程序直接终止！
    Python是希望在出现异常时，我们可以编写代码来对异常进行处理！    

    try语句
        try:
            代码块（可能出现错误的语句）
        except 异常类型 as 异常名:
            代码块（出现错误以后的处理方式）
        except 异常类型 as 异常名:
            代码块（出现错误以后的处理方式）
        except 异常类型 as 异常名:
            代码块（出现错误以后的处理方式）
        else：
            代码块（没出错时要执行的语句）    
        finally:
            代码块（该代码块总会执行）    

        try是必须的 else语句有没有都行
        except和finally至少有一个    

    可以将可能出错的代码放入到try语句，这样如果代码没有错误，则会正常执行，
        如果出现错误，则会执行expect子句中的代码，这样我们就可以通过代码来处理异常
        避免因为一个异常导致整个程序的终止            

## 异常的传播（抛出异常）
    当在函数中出现异常时，如果在函数中对异常进行了处理，则异常不会再继续传播,
        如果函数中没有对异常进行处理，则异常会继续向函数调用处传播,
        如果函数调用处处理了异常，则不再传播，如果没有处理则继续向调用处传播
        直到传递到全局作用域（主模块）如果依然没有处理，则程序终止，并且显示异常信息

    当程序运行过程中出现异常以后，所有的异常信息会被保存一个专门的异常对象中，
        而异常传播时，实际上就是异常对象抛给了调用处
        比如 ： ZeroDivisionError类的对象专门用来表示除0的异常
                NameError类的对象专门用来处理变量错误的异常
                ....

    在Python为我们提供了多个异常对象            

## 抛出异常
    - 可以使用 raise 语句来抛出异常，
        raise语句后需要跟一个异常类 或 异常的实例

## 文件（File）

    f = open("...",mode="",encoding="utf-8")
    content = f.read()
    f.close
    
- 打开文件模式

    r,w,a,r+,rb,r+b,...
    rb  读出来的是bytes类型
    
- 文件修改

    import os
    
    with open("file_old",mode="r",encoding="utf-8") as f1,\
         open("file_new",mode="r",encoding="utf-8") as f2:
    content = f1.read()
    new_content = content.replace("1","2")
    f2.write(new_content)
    
    os.remove("file_old")
    os.rename("file_new","file_old")
    
    占用内存过大,可以改为:
    
    for line in f1:
        new_line = line.replace("1","2")
        f2.write(new_line)
         



