# linux学习笔记


[Linux基本目录结构](#Linux基本目录结构)

[远程登录Linux系统](#远程登录Linux系统)

[vi和vim编辑器](#vi和vim编辑器)

[关机、重启和用户登录注销](#关机、重启和用户登录注销)

[用户管理](#用户管理)

[实用指令](#实用指令)

[组管理和权限管理](#组管理和权限管理)

[定时任务调度](#定时任务调度)

[Linux磁盘分区、挂载](#Linux磁盘分区&挂载)

[网络配置](#网络配置)

[进程管理(重点)](#进程管理)

[包管理工具(RPM和YUM)](#包管理工具)


Shell编程篇

[Shell简介](#Shell简介)

[Shell变量](#Shell变量)

[Shell字符串](#Shell字符串)

[Shell数组](#Shell数组)

[Shell运算符](#Shell运算符)

[Shell打印输出指令](#Shell打印输出命令)

[Shell test命令](#Shelltest命令)

[Shell流程控制](#Shell流程控制)

[Shell函数](#Shell函数)

[输入输出重定向](#输入输出重定向)

[shell文件包含](#Shell文件包含)



# Linux基本目录结构


## 1. 目录用途

Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包

目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。


# Linux基本目录结构


## 1. 目录用途

系统启动必须：
字段|说明
---|---
/boot|存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。
/etc|所有的系统管理所需要的配置文件和子目录my.conf。
/lib|系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。
/sys|这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs。

指令集合：
字段|说明
---|---
/bin|是Binary的缩写，这个目录存放着最经常使用的命令。
/sbin|s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。

外部文件管理：
字段|说明
---|---
/dev|类似windows的设备管理器，把所有的硬件用文件的形式存储。
/media|linux系统会自动识别一些设备，例如U盘光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。
/mnt|系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里面的内容了。
/lost+found|这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。
/tmp|这个目录是用来存放一些临时文件的。
/run|是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。

账户：
字段|说明
---|---
/home|存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。
/root|该目录为系统管理员，也称作超级权限者的用户主目录。
/usr|这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。
/usr/local|这是另一个给主机额外安装软件所安装的目录，一般是通过编译源码的方式安装的程序。

运行过程中要用：
字段|说明
---|---
/var|这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件。
/proc|这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。

扩展用的：
字段|说明
---|---
/srv|service的缩写，该目录存放一些服务启动之后需要提供的数据。
/opt|这是给主机额外安装软件所摆放的目录，如安装ORACLE数据库就可放到该目录下。默认为空。

## 目录

字段|说明
---|---
./|当前目录
../|上一级目录

## 2. 总结

1. Linux的目录中有且只有一个根目录。
2. Linux的各个目录存放的内容是规划好，不用乱放文件。
3. Linux是以文件的形式管理我们的设备，因此linux系统，一切皆为文件。
4. Linux的各个文件目录下存放什么内容，必须有一个认识。



# 远程登录Linux系统

## 1. 远程登录方法

### 1.1Xshell

* 可用Xshell等软件输入主机的IP地址，登录名链接

### 1.2ssh

* 链接指令 ssh -p 22 [登录用户]@[地址]

## 2. ftp文件传输

* 主要用于向服务上传或下载文件

# vi和vim编辑器

## 1. vi和vim的基本介绍

* 所有Linux系统都会内置vi文本编辑器
* vim是vi的升级版，可以主动以字体颜色分辨语法的正确性，代码补完和编译，错误跳转等功能。

## 2. vi和vim的三种模式

### 2.1 正常模式

* 在正常模式下，我们可以使用快捷键。
* 用vim打开一个文件就直接进入一般模式
* 可以使用【删除字符】或【删除整行】来处理文档内容，也可以使用【复制黏贴按钮】

### 2.2 插入/编辑模式

* 在这个模式下，可以编辑文件内容。
* 按下i,I,o,O,a,A,r,R等字母就可进入编辑模式

### 2.3 命令行模式

* 在这个模式中，可以利用指令完成读取，存盘，替换，离开，显示行号的等动作。
* wq保存退出
* q无修改直接退出
* q!不保存修改直接退出


## 3. Vim 的常见指令案例

1. yy：拷贝当前行
2. 5yy：拷贝当前5行
3. dd：删除当前行
4. 5dd：删除当前行向下的5行
5. 在文件中查找某个单词：命令行输入 /（查找内容），按n查找下一个
6. 设置文件行号：set nu，取消文件行号：set nonu
7. 编辑文件，正常模式下使用快捷键到达文档最末行：G，最首行：gg
8. 撤销输入：在正常模式下输入u
9. 编辑文件，光标移动到某行：shift+g
    * 显示行号：set nu
    * 输入行号这个数
    * 输入shift+g

## 4. vim其他常见指令补充

### 4.1 文件命令

指令|说明
---|---
vim [file1 file2 file3 ...]|打开单个或多个文件
:open file|在vim窗口中打开一个新文件
:split file|在新窗口中打开文件（split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。）
Ctrl+ww| 移动到下一个窗口
Ctrl+wj |移动到下方的窗口
Ctrl+wk |移动到上方的窗口
:close |最后一个窗口不能使用此命令，可以防止意外退出vim。
:only|关闭所有窗口，只保留当前窗口
:bn|切换到下一个文件
:bp|切换到上一个文件
:args|查看当前打开的文件列表，当前正在编辑的文件会用[]括起来
:e <ftp://192.168.10.76/abc.txt>| 打开远程文件，比如ftp或者share folder

### 4.2 普通模式

#### 4.2.1 插入命令

指令|说明
---|---
i |在当前位置生前插入
I |在当前行首插入
a |在当前位置后插入
A |在当前行尾插入
o |在当前行之后插入一行
O |在当前行之前插入一行

#### 4.2.2 游标移动

指令|说明
---|---
gg |移动到文件头。 = [[
G（shift + g）| 移动到文件尾。 = ]]
行數 → G|移動到第 n 行
冒号+行号，回车| 比如跳到240行就是 :240回车
h | 左移一个字符
l|右移一个字符，这个命令很少用，一般用w代替。
k |上移一个字符
j |下移一个字符
w |向前移动一个单词（光标停在单词首部）
b | 向后移动一个单词 2b 向后移动2个单词
e |同w，只不过是光标停在单词尾部
ge |同b，光标停在单词尾部。
^|移动到本行第一个非空白字符上。
0|移动到本行第一个字符上
HOME |移动到本行第一个字符。同0健。
$ |移动到行尾 3$ 移动到下面3行的行尾
f（find）| fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。
F |同f，反向查找

#### 4.2.3 撤销和重做

指令|说明
---|---
u |撤销（Undo）
U |撤销对整行的操作
Ctrl + r |重做（Redo），即撤销的撤销。

#### 4.2.4 删除命令

指令|说明
---|---
x |删除当前字符
3x |删除当前光标开始向后三个字符
X |删除当前字符的前一个字符。X=dh
dl |删除当前字符， dl=x
dh |删除前一个字符
dd |删除当前行
dj |删除上一行
dk |删除下一行
10d |删除当前行开始的10行。
D |删除当前字符至行尾。D=d$
d$ |删除当前字符之后的所有字符（本行）
kdgg |删除当前行之前所有行（不包括当前行）
jdG（jd shift + g） |删除当前行之后所有行（不包括当前行）
:1,10d |删除1-10行
:11,$d |删除11行及以后所有的行
:1,$d |删除所有行
J(shift + j)|删除两行之间的空行，实际上是合并两行。

#### 4.2.5 拷贝，剪贴和粘贴

指令|说明
---|---
yy |拷贝当前行
nyy |拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。
p |在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。
shift+p |在当前行前粘贴
:1,10 co 20 |将1-10行插入到第20行之后。
:1,$ co $ |将整个文件复制一份并添加到文件尾部。
ddp |交换当前行和其下一行
xp| 交换当前字符和其后一个字符
ndd|剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴
:1,10d|将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。
:1, 10 m 20 |将第1-10行移动到第20行之后。

正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制

#### 4.2.6 退出命令

指令|说明
---|---
:wq |保存并退出
ZZ |保存并退出
:q! |强制退出并忽略所有更改
:e! |放弃所有修改，并打开原来文件。
:q | 未修改直接退出

#### 4.2.7 注释命令

perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#

指令|说明
---|---
3,5 s/^/#/g |注释第3-5行
3,5 s/^#//g |解除3-5行的注释
1,$ s/^/#/g |注释整个文档。
:%s/^/#/g |注释整个文档，此法更快。

### 4.3 执行shell命令

* :!command

指令|说明
---|---
:!ls |列出当前目录下文件
:!perl -c script.pl |检查perl脚本语法，可以不用退出vim，非常方便。
:!perl script.pl |执行perl脚本，可以不用退出vim，非常方便。
:suspend或Ctrl - Z |挂起vim，回到shell，按fg可以返回vim。

### 4.4 帮助命令

指令|说明
---|---
:help or F1 |显示整个帮助
:help xxx |显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。
:help 'number' |Vim选项的帮助用单引号括起
:help \<Esc\> |特殊键的帮助用<>扩起
:help -t |Vim启动参数的帮助用-
：help i_\<Esc\>| 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式

帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回

### 4.5 其他非编辑命令

指令|说明
---|---
. |重复前一次命令
:set ruler?　|查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看
:scriptnames　|查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。
:set list |显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:>-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了 expandtab，那么tab将被扩展为空格。

* Vim教程
  * 在Unix系统上 $ vimtutor
  * 在Windows系统上 :help tutor

* 录制宏:
  * 按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。

* :syntax 列出已经定义的语法项
* :syntax clear 清除已定义的语法规则
* :syntax case match 大小写敏感，int和Int将视为不同的语法元素
* :syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案


# 关机、重启和用户登录注销

## 1. 关机&重启命令

### 1.1 shutdown

* shutdown -h now：表示立即关机
* shutdown -h 1：表示1分钟后关机
* shutdown -r now：立即重启

### 1.2 halt

* halt：直接使用，关机

### 1.3 reboot

* reboot 重启系统

### 1.4 sync

* sync：把内存的数据同步到磁盘上

当我们关机或者重启时，都应该先执行一下sync，防止数据丢失。

## 2. 用户登录注销

* 登录时少用root账号登录，以避免操作失误的损失
* 平时可登录普通账户，再用“su - 用户名”切换成管理员登录

### 2.1 logout

* logout：注销用户

, 在图形运行级别无效，在运行级别3有效。

# 用户管理

## 1. 基本用户管理

 * Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。
 * 用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。
 * 每个用户账号都拥有一个唯一的用户名和各自的口令。
 * 要完成的工作主要有如下几个方面：
   * 用户账号的添加、删除与修改。
   * 用户口令的管理。
   * 用户组的管理。

### 1.1 添加用户

 添加用户：useradd [选项] 用户名。

#### 1.1.1 参数说明

* 选项:
  * -c comment 指定一段注释性描述。
  * -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。
  * -g 用户组 指定用户所属的用户组。
  * -G 用户组，用户组 指定用户所属的附加组。
  * -s Shell文件 指定用户的登录Shell。
  * -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。
  * -f [缓冲天数] 指定在密码过期后多少天即关闭该帐号。
  * -e 有效期限 指定帐号的有效期限；
  * -M：不要自动建立用户的登入目录；

* 用户名:
  * 指定新账号的登录名。

#### 1.1.2 实例

1. useradd –d  /home/sam -m sam
    * 此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 /home/sam（/home为默认的用户主目录所在的父目录）。
2. useradd -s /bin/sh -g group –G adm,root gem
    * 新建了一个用户gem，该用户的登录Shell是 /bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。
  
### 1.2 用户口令的管理

 指定和修改用户口令: passwd 选项 用户名

#### 1.2.1 参数说明

* 选项：
  * -l 锁定口令，即禁用账号。
  * -u 口令解锁。
  * -d 使账号无口令。
  * -f 强迫用户下次登录时修改口令。

#### 1.2.2 注意事项

* 如果默认用户名，则修改当前用户的口令。
  * 假设当前用户是sam，则下面的命令修改该用户自己的口令：passwd sam
* 普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；
* 超级用户为用户指定口令时，就不需要知道原口令。

#### 1.2.3 案例

1. passwd -l sam
    * 用 -l(lock) 选项锁定某一用户，使其不能登录
2. passwd -d sam
    * 为用户指定空口令

### 1.3 删除帐号

 删除帐号: userdel 选项 用户名

#### 1.3.1 注意事项

* 常用的选项是 -r，它的作用是把用户的主目录一起删除。
  * userdel -r sam

### 1.4 修改帐号

 修改已有用户的信息: usermod 选项 用户名

#### 1.4.1 注意事项

* 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。

### 1.5 查询用户信息

* 查询用户信息: id 用户名
  * 用户不存在是返回“无此用户”
* 查看当前用户/登录用户：who am i

### 1.6 切换用户

* 切换用户：su - 切换用户名
  * 从权限高切换到权限低的用户不需要输密码。
  * 返回切换前的用户：exit

## 2. 用户组的管理

 每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。
 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。

### 2.1 增加一个新的用户组

 增加一个新的用户组: groupadd 选项 用户组

#### 2.1.1 说明

* 选项有：
  * -g GID 指定新用户组的组标识号（GID）。
  * -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。

#### 2.1.2 案例

1. groupadd -g 101 group2
    * 向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。
2. groupadd -g 101 group2
    * 向系统中增加了一个新组group2，同时指定新组的组标识号是101。

### 2.2 删除用户组

 删除用户组: groupmod 选项 用户组

#### 2.1.2 说明

* 选项有：
  * -g GID 为用户组指定新的组标识号。
  * -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。
  * -n新用户组 将用户组的名字改为新名字

#### 2.1.3 案例

1. groupmod -g 102 group2
    * 将组group2的组标识号修改为102。
2. groupmod –g 10000 -n group3 group2
    * 将组group2的标识号改为10000，组名修改为group3。

### 2.3 组的切换

 用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：

 * $ newgrp root
   * 这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。

## 3. 与用户账号有关的系统文件

### 3.1 /etc/passwd 文件

用户（user）的配置文件，记录用户的各种信息。

* 每行的含义：
  1. "用户名"是代表用户账号的字符串。
        * 通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号\(:\)，因为冒号在这里是分隔符。
        * 为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。
  2. “口令”一些系统中，存放着加密后的用户口令字。
        * 虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。
  3. “用户标识号”是一个整数，系统内部用它来标识用户。
        * 一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。
        * 通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。
  4. “组标识号”字段记录的是用户所属的用户组。
        * 它对应着/etc/group文件中的一条记录。
  5. “注释性描述”字段记录着用户的一些个人情况。
        * 例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。
  6. “主目录”，也就是用户的起始工作目录。
        * 它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。
  7. 用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。
        * Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。
        * 系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。
        * 用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。
        * 利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。
  8. 系统中有一类用户称为伪用户（pseudo users）。
        * 这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。

### 3.2 /etc/shadow 文件

口令配置文件

* 每行的含义：
  1. "登录名"是与/etc/passwd文件中的登录名相一致的用户账号
  2. "口令"字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。
  3. "最后一次修改时间"表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。
  4. "最小时间间隔"指的是两次修改口令之间所需的最小天数。
  5. "最大时间间隔"指的是口令保持有效的最大天数。
  6. "警告时间"字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。
  7. "不活动时间"表示的是用户没有登录活动但账号仍能保持有效的最大天数。
  8. "失效时间"字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。


### 3.3 /etc/group 文件

组（group）的配置文件，用户组的所有信息都存放在/etc/group文件中。

* 每行含义：
  1. "组名"是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。
  2. "口令"字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。
  3. "组标识号"与用户标识号类似，也是一个整数，被系统内部用来标识组。
  4. "组内用户列表"是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。

  
# 实用指令

## 1. 指定运行级别（7个级别）

* 0.关机
* 1.单用户【找回丢失密码】
* 2.多用户状态没有网络服务
* 3.多用户状态有网络服务
* 4.系统未使用保留给用户
* 5.图形界面
* 6.系统重启

* 系统的运行级别配置文件：/etc/inittab

* 切换到指定运行级别的指令：init [012356]

## 2. 帮助指令

### 2.1 man获得帮助信息

man [命令或配置文件]

* 例如:man ls

### 2.2 help指令

help [命令或配置文件]

## 3. 文件目录类指令

### 3.1 文件剪贴删除复制重名等

* pwd：Print Working Directory，显示当前工作目录的绝对路径。
* ls：-a：显示当前目录所有的文件和目录，包括隐藏的；
  * -l：以列表的方式显示信息。
* cd：cd ~：回到自己的家目录；cd …：回到当前目录的上一级目录。
* mkdir：创建目录；-p：创建多级目录。
* rmdir：删除空目录。rmdir不能删除非空的目录。如果需要删除非空的目录，需要使用rm -rf。
* cp：拷贝文件到指定目录；
  * -r：递归复制整个文件夹。强制覆盖不提示的方法：
  * cp命令改为\cp
* rm：移除文件或目录；
  * -r：递归删除整个文件夹；
  * -f：强制删除不提示。
* mv：移动文件与目录或重命名，两种功能！
* touch：创建空文件。可以一次性创建多个文件
* ln 给文件创建一个软连接
  * 用法:ln -s[源文件或目录][软连接名]

### 3.2 文件查看

* cat：查看文件内容。只能浏览文件，而不能修改文件。
  * -n：显示行号。
  * 结尾加上 | more：分页显示，不会全部一下显示完。
* more：是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more还内置了很多快捷键：
  * 空白键（Space）：向下翻一页
  * Enter：向下翻一行
  * q：立刻离开more，不再显示该文件内容
  * Ctrl + F：向下滚动一屏
  * Ctrl + B：返回上一屏
  * = :输出当前行的行号
  * :f 输出文件名和当前行的行号
* less：用来分屏查看文件内容，与more相似，但是更强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容。对于显示大型文件具有较高的效率。
* head：显示文件的开头部分。-n 5：看前面5行内容。
* tail：输出文件中尾部的内容。
  * -n 5：看后面5行内容。
  * -f：时事追踪该文档的所有更新
* \>指令：输出重定向。如果不存在会创建文件，否则会将原来的文件内容覆盖。
* \>>指令：追加。如果不存在会创建文件，否则不会覆盖原来的文件内容，而是追加到文件的尾部。
* echo：输出内容到控制台。
* history：查看历史指令

### 3.3 时间和日期

* date：显示当前日期和时间
  * date “+%Y”：显示当前年份
  * date “+%d”：显示当前月份
  * date “+%Y-%m-%d %H:%M:%S”：显示年-月-日 时：分：秒
  * 设置日期：date -s 字符串时间
* cal：查看日历指令；
  * cal [月] [年份]：显示某一年或月的日历

### 3.4 搜索查找类

* find：从指定目录向下递归的遍历其各个子目录，将满足条件的文件或者目录显示在终端。
  * find (搜索范围) -name (文件名)：按照指定的文件名查找模式查找文件。
  * find (搜索范围) -user (用户名)：按照指定的用户名查找模式查找文件。
  * find (搜索范围) -size (+多少/-多少/多少)：按照指定的文件大小查找模式查找文件（大于多少/小于多少/等于多少）
  * 查询 /目录下所有.txt的文件：find / -name *.txt
* locate：locate (搜索文件)
  * 可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。
  * locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻。
  * 在第一次运行之前，必须使用updatedb指令创建locate数据库。
* grep：过滤查找，表示将前一个命令的处理结果输出传递给后面的命令处理。经常跟管道一起使用。
  * grep [选项] 查找内容 源文件
  * -n：显示匹配行及行号。
  * -i：忽略大小写字母。
  * cat hello.txt | grep yes

### 3.5 压缩和解压类

* gzip/gunzip：压缩文件/解压
  * gzip (文件)：压缩为.gz文件，原来文件不保留。
  * gunzip (文件)：解压缩，同样也不保留源文件。
* zip/unzip：压缩文件/解压
  * zip [选项] (压缩后文件xxx.zip) (将要压缩的文件)
  * unzip [选项] (要解压的文件xxx.zip)
  * zip -r：递归压缩，即压缩目录
  * unzip -d (目录)：指定解压后的文件的存放目录
* tar：打包指令，最后打包后的文件是.tar.gz的文件
  * tar [选项] xxx.tar.gz (打包的内容)
  * -c：产生.tar打包文件
  * -v：显示详细信息
  * -f：指定压缩后的文件名
  * -z：打包同时压缩
  * -x：解压.tar文件
  * 压缩：tar -zcvf (压缩后文件名) (要压缩的文件)
  * 解压：tar -zxvf (要解压的文件)
  * 解压到指定目录：tar -zxvf (要解压的文件) -C (指定目录)，指定解压到的目录要存在。

# 组管理和权限管理

## 1. Linux组基本介绍

* Linux中每个用户属于一个组，不能独立于组以外。所以在Linux中每个文件存在组的概念：
    1. 所有者
    2. 所在组
    3. 其他组
    4. 改变用户所在组

## 2. 文件/目录所有者

一般为文件的创建者，谁创建了该文件，就自然的称为该文件的所有者。

* 查看文件所有者：ls -ahl
* 修改文件所有者：chown (用户名) (文件名)

## 3. 文件/目录所在组

当某个用户创建了一个文件之后，默认之歌文件所在组就是该用户所在的组

* 查看文件所有者：ls -ahl
* 修改文件所在组：chgrp (组名) (文件名)

## 4. 其他组

除文件的所有者和所在组的用户外，系统的其他用户都是文件的其他组

## 5. 文件属性

1. 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。
    * 当为[ d ]则是目录
    * 当为[ - ]则是文件；
    * 若是[ l ]则表示为链接文档(link file)；
    * 若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；
    * 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。
2. 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。
每个文件的属性由左边第一部分的10个字符来确定(文件类型-属主权限-属组权限-其它用户权限)。

### 5.1 rwx权限详解

* rwx作用到文件：
  * r：read，可读。读取查看。
  * w：write，可以修改。但不代表可以删除该文件。删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件。
  * x：execute，可执行。可以被执行。
* rwx作用到目录：
  * r：可以读取，ls查看目录内容。
  * w：可以修改，目录内创建+删除+重命名目录。
  * x：可执行，可以进入该目录。

### 5.2 修改权限

#### 5.2.1 chgrp：更改文件属组

* chgrp [-R] 属组名 文件名
  * -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。
  
#### 5.2.2 chown：更改文件属主，也可以同时更改文件属组

语法:

* chown [–R] 属主名 文件名
* chown [-R] 属主名：属组名 文件名

#### 5.2.3 chmod：更改文件9个属性

* Linux文件属性有两种设置方法，一种是数字，一种是符号。
* Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。
* 我们可以使用数字来代表各个权限，各权限的分数对照表如下：
  * r:4
  * w:2
  * x:1
* 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx---] 分数则是：
  * owner = rwx = 4+2+1 = 7
  * group = rwx = 4+2+1 = 7
  * others= --- = 0+0+0 = 0

##### 5.2.3.1 使用数字修改权限

* **chmod [-R] xyz 文件或目录**
  * xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。
  * -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更

##### 5.2.3.1 使用符号修改权限

* 我们就可以使用 u(user), g(group), o(others) 来代表三种身份的权限！
* 此外， a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x。

# 定时任务调度

## 1. 任务调度原理

crond任务调度：crontab进行定时任务调度  

* 使用方法：crontab [选项]
  * crontab [选项]
  * -e：编辑crontab定时任务
  * -i：查询crontab任务
  * -r：删除当前用户所有的crontab任务
  * -l：列出当前有哪些任务调度
  * service crond restart：重启任务调度
  * 当保存退出后就生效了
  * 参数细节说明

项目|含义| 范围
---|---|---
第一个“*”|一小时当中的第几分钟|0-59
第二个“*”|一天当中的第几小时|0-23
第三个“*”|一个月当中的第几天|1-31
第四个“*”|一年当中的第几月|1-12
第五个“*”|一周当中的星期几|0-7（0和7都代表星期日）

* 特殊符号说明
  * \*：代表任何时间。比如第一个*就代表一小时中每分钟都执行一次的意思。
  * ,：代表不连续的时间。比如“0 8,12,16 \* * *命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令。
  * -：代表连续的时间范围。比如“0 5 * * 1-6命令”，代表在周一到周六的凌晨5点0分执行命令。
  * /n：代表每隔多久执行一次。比如“*/10 \* * * * 命令”，代表每隔10分钟就执行一遍命令。


# Linux磁盘分区&挂载

## 1. 分区方式

* mbr分区
  * 最多支持四个主分区
  * 系统只能安装在主分区
  * 扩展分区要占一个主分区
  * MBR最大只支持2TB，但拥有最好的兼容性
* gpt分区
  * 支持无限多个主分区（但操作系统可能限制，比如windows下最多128个分区）
  * 最大支持18EB的大容量（1EB=1024PB，PB=1024TB）
  * windows7 64位以后支持gpt

## 2. Linux分区

### 2.1 分区原理

* Linux来说无论有几个分区，分给哪一个目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构，Linux中每个分区都是用来组成整个文件系统的一部分。
* Linux采用了一种叫做“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。

### 2.2 硬盘说明

* Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘
* lsblk [-f]：查看当前系统的分区和挂载情况。（list block）

### 3. 挂载硬盘

需求是给我们的Linux系统增加一个新的硬盘，并且挂载到/home/newdisk

1. 添加硬盘
2. 分区：fdsk /dev/sdb
3. 格式化：mkfs -t ext4 /dev/sdb1
4. 挂载：新建目录：mkdir /home/newdisk；挂载：mount /dev/sdb1 /home/newdisk
5. 设置可以自动挂载（永久挂载）：重启系统后，仍然可以挂载。vim etc/fstab 增加挂载信息。mount -a：生效

### 3.1 具体步骤

#### 3.1.1 增加硬盘

 虚拟器菜单中设置

#### 3.1.2 硬盘分区

fdisk/     /dev/sdb
对/sdb分区
m　　显示命令列表
p　　显示磁盘分区　同fdisk　-1
n　　新增分区
d　　删除分区
w　　写入并退出

#### 3.1.3 格式化磁盘

mkfs -t  ext4  /dev/sdb1
其中ext4是分区类型

#### 3.1.4 挂载硬盘

挂载：将一个分区与一个目录联系起来
mount 设备名称 挂载目录
unmount 设备名称/挂载目录

#### 3.1.5 永久挂载

通过修改/etc/fstab实现挂载
添加完成后，执行mount -a生效

### 3.2 取消挂载

取消挂载：unmount /dev/sdb1

## 4. 磁盘状况查询

* 磁盘情况查询：df -h / df -l

* 查询指定目录的磁盘占用情况：du -h /目录，默认为当前目录
  * -s：指定目录占用大小汇总
  * -h：带计量单位
  * -a：含文件
  * –max-depth=1：子目录深度
  * -c：列出明细的同时，增加汇总值

* 磁盘情况-工作实用指令
  * 统计/home文件夹下文件的个数：ls -l /home | grep "^-" | wc -l
  * 统计/home文件夹下目录的个数：ls -l /home | grep "^d" | wc -l
  * 统计/home文件夹下文件的个数，包括子文件夹里的：ls -lR /home | grep "^-" | wc -l
  * 统计文件夹下目录的个数，包括子文件夹里的：ls -lR /home | grep "^d" | wc -l
  * 以树状显示目录结构：首先安装tree指令：yum install tree，tree

# 网络配置

## 1 Linux网络配置原理

## 2 查看网络IP和网关

### 2.1 虚拟机网络编辑器

### 2.2 修改IP地址

### 2.3 查看网关

### 2.4 查看windows中的虚拟网卡的ip地址

windows中使用ipconfig查看ip配置

## 3. ping测试

基本语法: ping [主机地址]

* 例如： ping www.baidu.com

## 4. Linux网络环境配置

### 4.1 自动抓取IP地址

**`缺点：`** 每次自动获取的ip地址可能不一样，不适用于做服务器

### 4.2 指定ip地址

1. 直接修改配置文件来指定IP，并可以连接到外网，编辑：vim /etc/sysconfig/network-scripts/ifcfg-eth0
2. 重启网络服务：service network restart
3. 重启系统：reboot

# 进程管理

## 2. 显示系统执行的进程

### 2.1 ps指令详细介绍

* ps [选项]：查看目前系统中，有哪些正在执行，以及它们执行的状况

        ps -a：显示当前终端的所有进程信息。
        ps -u：以用户的格式显示进程信息。
        ps -x：显示后台进程运行的参数。
        ps -axu | grep xxx：过滤得到xxx的信息。
        ps -ef：以全格式显示当前所有的进程，查看进程的父进程。
        -e：显示所有进程。
        -f：全格式。

字段|说明
---|---
USER|用户说明
PID|进程识别号
%CPU|进程占用cpu百分比
%MEM|进程占用物理内存百分比
VSZ|进程占用虚拟内存大小(KB)
RSS|进程占用物理内存大小(KB)
TTY|终端机号
STAT|进程状态，S睡眠，s代表是会话的先导进程，N代表进程拥有比普通进程更高的优先级，R正在运行，D短期等待，Z僵死进程，T被跟踪或被停止
STARTED|进程启动的时间
TIME|此进程所消耗的CPU时间
COMMAND|正在执行的命令或进程名


字段|说明
---|---
UID|用户id
PID|进程id
PPID|父进程
C|CPU用于执行优先级的因子，数值越大，表明cpu密集型运算，执行优先级会降低，数值越小，表明是I/O密集运算，执行优先级会提高
STIME|进程启动时间
TTY|终端机号
TIME|此进程所消耗的CPU时间
CMD|启动所用的命令和参数

## 3. 终止进程

* 若是某个进程执行一半需要停止时，或是消耗了很大的系统资源时，此时可以考虑停止该进程，使用kill命令来完成此任务

        kill [选项] 进程号：通过进程号杀死进程
        -9：表示强迫进程立刻停止
        killall 进程名称：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用


## 4. 查看进程树

* 查看进程树：pstree [选项]
  * -p：显示进程的PID
  * -u：显示进程的所属用户

## 5. 服务(Service)管理

服务(Service)本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysql,sshd 防火墙等),因此我们又称为守护进程。

### 5.1 service管理指令

service管理指令：service 服务名 [start | stop | restart | reload | status]  
在CentOS7.0之后，不再使用service，而是systemctl

* 查看防火墙情况：
  * service iptables status
  * systemctl status firewalld（7.0之后的版本）

* 测试某个端口是否在监听：telnet

### 5.2 服务查看方式

* 方式1：setup指令
* 方式2：ls -l /etc/init.d/

### 5.3 服务的运行级别（runlevel）

* 查看或修改默认级别：vim /etc/inittab
* 每个服务对应的每个运行级别都可以设置
[详细见3.5实用指令第一部分](3.5实用指令.md)

### 5.4 开机流程

操作系统--/boot--init进程--运行级别--/etc/init.d

### 5.5 chkconfig指令

chkconfig：可以给每个服务的各个运行级别设置自启动/关闭

#### 5.5.1 基本语法

        查看xxx服务：chkconfig –list | grep xxx
        查看服务的状态：chkconfig 服务名 --list
        给服务的运行级别设置自启动：chkconfig –level 5 服务名 on/off
        要所有运行级别关闭或开启：chkconfig 服务名 on/off
        **chkconfig重新设置后需要重新启动才能生效**

## 6. 动态监控进程

top与ps相似，都是用来显示正在执行的进程，top的不同之处在于top执行一段时间可以更新正在运行的进程

### 6.1 基本语法

* top [选项]

        -d 秒数：指定top命令每隔几秒更新。默认是3秒。
        -i：使top不显示任何闲置或者僵死进程。
        -p：通过指定监控进程ID来仅仅监控某个进程的状态。

* 交互操作说明：

操作|功能
---|---
P|以CPU使用率排序，默认就是此项
M|以内存的使用率排序
N|以PID排序
q|退出top


### 6.2 应用案例

#### 6.2.1  监控特定用户

1. top查看进程；
2. u
3. 输入用户名。

#### 6.2.2 终止指定的进程

1. top查看进程；
2. k输入要结束的进程。

## 7. 查看网络情况

### 7.1 基本语法

netstat [选项]

         -an：按一定顺序排列输出
         -p：显示哪个进程在调用

### 7.2 应用案例

1. 查看所有的网络服务
    * netstat -anp | more

2. 查看sshd的服务的信息
    * netstat -anp | grep sshd

# 包管理工具

## 1. RPM包

RPM：RedHat Package Manager，红帽软件包管理工具。
Linuxd分发版本都有采用（suse,redhat，centos等）

### 1.1 rpm指令

#### 1.1.1 查看指令

* RPM查询已安装的rpm列表：rpm -qa | grep xx
  * 查看是否安装firefox：rpm -qa |grep firefox

* rpm -qa：查询所安装的所有rpm软件包
* rpm -qa | more
* rpm -qa | grep xx
* rpm -q xx：查询xx软件包是否安装
* rpm -qi xx：查询软件包信息
* rpm -ql xx：查询软件包中的文件
* rpm -qf 文件全路径名：查询文件所属的软件包

#### 1.1.2 卸载指令

* 卸载rpm包：rpm -e 软件包名称
* 如果其他软件依赖于要卸载的包，删除时可能会发生依赖错误
* 忽视依赖强制删除的方法：rpm -e --nodeps 软件包名称 可以强制删除，但不建议这样做，否则会导致程序无法运行

#### 1.1.3安装指令

* 安装rpm包：rpm -ivh 软件包全路径名称
  * i=install：安装
  * v=verbose：提示
  * h=hash：进度条

## 2. YUM

yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。
基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。

* yum list | grep xx：查询yum服务器是否有需要安装的软件
* yum install xx：安装指定的yum包
* yum -y remove xx：卸载指定的yum包

# Shell编程

# Shell简介

## 1. Shell基础

* Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。
* Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。
* Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。

## 1.1 什么是shell

Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便裕兴程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。

### 1.2 shell脚本

Shell 脚本（shell script），是一种为 shell 编写的脚本程序。  
业界所说的 shell 通常都是指 shell 脚本，但读者朋友要知道，shell 和 shell script 是两个不同的概念。

### 1.3 Shell 环境

Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。

* Linux 的 Shell 种类众多，常见的有：
  * Bourne Shell（/usr/bin/sh或/bin/sh）
  * Bourne Again Shell（/bin/bash）
  * C Shell（/usr/bin/csh）
  * K Shell（/usr/bin/ksh）
  * Shell for Root（/sbin/sh）
* 本教程关注的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。
* 在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 #!/bin/sh，它同样也可以改为 #!/bin/bash。

## 2. Shell脚本的运行

### 2.1 脚本的格式

* 脚本以#!/bin/bash 开头

### 2.2 脚本的执行

1. 赋予用户脚本执行权限
     * chmod +x ./test.sh  #使脚本具有执行权限
     * ./demo.sh
     * 注意，一定要写成 ./demo.sh，而不是 demo.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 demo.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 demo.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。

2. 作为解释器参数
    * 这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：
        * /bin/sh test.sh
        * /bin/php test.php
        * sh demo.sh
    * 一般不这么用

# Shell变量

## 1. shell变量简介

* Linux Shell的变量分为，系统变量和用户自定义变量
* 系统变量：$HOME、$PWD、$SHELL、$USER等等
* 显示当前shell中所有变量：set

### 1.1 变量规则

* 变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：
* 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。
* 中间不能有空格，可以使用下划线（_）。
* 不能使用标点符号。
* 不能使用bash里的关键字（可用help命令查看保留关键字）。
* 变量名称一般习惯为大写

### 1.2 shell变量的定义

#### 1.2.1 基本语法

* 定义变量：变量=值，=两边不能有空格
* 撤销变量：unset 变量
* 声明静态变量：readonly 变量，注意：`不能unset`

#### 1.2.2 将命令的返回值赋给变量

* A=ls -la这里有反引号（ESC下面），运行里面的命令，并把结果返回给变量A
* A=$(ls -la)等价于上面

### 1.3 使用变量

* 使用一个定义过的变量，只要在变量名前面加美元符号即可，如：

```sh
your_name="qinjx"
echo $your_name
echo ${your_name}
```

* 量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：

```sh
for skill in Ada Coffe Action Java; do
    echo "I am good at ${skill}Script"
done
```

### 1.4 静态变量

* 使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。
* 下面的例子尝试更改只读变量，结果报错：

```sh
#!/bin/bash
myUrl="http://www.google.com"
readonly myUrl
myUrl="http://www.runoob.com"
#######
# $/bin/sh: NAME: This variable is read only.
```

### 1.5 删除变量

* 使用 unset 命令可以删除变量。语法：unset variable_name
* 变量被删除后不能再次使用。unset 命令不能删除只读变量。

### 1.6 变量类型

1. `局部变量` 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。
2. `环境变量` 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。
3. `shell变量` shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行

## 2. 环境变量

所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。

* 基本语法
* export 变量名=变量值：将shell变量输出为环境变量
* source 配置文件：让修改后的配置文件信息立即生效
* echo $变量名：查询环境变量的值

## 3. Shell 注释

* 以 # 开头的行就是注释，会被解释器忽略。
* 通过每一行加一个 # 号设置多行注释，像这样：

```sh
#--------------------------------------------
# 这是一个注释
# author：菜鸟教程
# site：www.runoob.com
# slogan：学的不仅是技术，更是梦想！
#--------------------------------------------
##### 用户配置区 开始 #####
#
#
# 这里可以添加脚本描述信息
#
#
##### 用户配置区 结束  #####
```

多行注释

* 多行注释还可以使用以下格式：

```sh
:<<EOF
注释内容...
注释内容...
注释内容...
EOF
```

* EOF 也可以使用其他符号:

```sh
:<<'
注释内容...
注释内容...
注释内容...
'

:<<!
注释内容...
注释内容...
注释内容...
!
```

## 4. 位置参数,预定义变量

* 我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……

```sh
#!/bin/bash

echo "Shell 传递参数实例！";
echo "执行的文件名：$0";
echo "第一个参数为：$1";
echo "第二个参数为：$2";
echo "第三个参数为：$3";

:<<!
chmod +x test.sh
$ ./test.sh 1 2 3
Shell 传递参数实例！
执行的文件名：./test.sh
第一个参数为：1
第二个参数为：2
第三个参数为：3
!
```

* 另外，还有几个特殊字符用来处理参数：

参数处理|说明
---|---
\$\#|传递到脚本的参数个数
\$\*|以一个单字符串显示所有向脚本传递的参数。如"\$*"用「"」括起来的情况、以"\$1 \$2 … \$n"的形式输出所有参数。
\$$|脚本运行的当前进程ID号
$!|后台运行的最后一个进程的ID号
\$@|与\$*相同，但是使用时加引号，并在引号中返回每个参数。如"\$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。
\$-|显示Shell使用的当前选项，与set命令功能相同。
\$?|显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。

```sh
#!/bin/bash
echo "Shell 传递参数实例！";
echo "第一个参数为：$1";
echo "参数个数为：$#";
echo "传递的参数作为一个字符串显示：$*";

:<<!
$chmod +x test.sh
$./test.sh 1 2 3
Shell 传递参数实例！
第一个参数为：1
参数个数为：3
传递的参数作为一个字符串显示：1 2 3
!
```

# Shell字符串

字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。

## 1. 单引号

```sh
str='this is a string'
```

* 单引号字符串的限制：
  * 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；
  * 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。

## 2. 双引号

```sh
your_name='runoob'
str="Hello, I know you are \"$your_name\"! \n"
echo -e $str

# 输出结果为：
# Hello, I know you are "runoob"!
```

* 双引号的优点：
  * 双引号里可以有变量
  * 双引号里可以出现转义字符

## 3. 拼接字符串

```sh
your_name="runoob"

# 使用双引号拼接
greeting="hello, "$your_name" !"
greeting_1="hello, ${your_name} !"
echo $greeting  $greeting_1
# 使用单引号拼接
greeting_2='hello, '$your_name' !'
greeting_3='hello, ${your_name} !'
echo $greeting_2  $greeting_3

#输出结果为：
#hello, runoob ! hello, runoob !
#hello, runoob ! hello, ${your_name} !
```

## 4. 获取字符串长度

```sh
string="abcd"
echo ${#string} #输出 4
```

## 5. 提取子字符串

以下实例从字符串第 2 个字符开始截取 4 个字符：

```sh
string="runoob is a great site"
echo ${string:1:4} # 输出 unoo
```

## 6. 查找子字符串

查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：

```sh
string="runoob is a great site"
echo `expr index "$string" io`  # 输出 4
注意： 以上脚本中 ` 是反引号，而不是单引号 '，不要看错了哦。
```

# Shell数组

* 数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。

## 1. 数组赋值

* 与大部分编程语言类似，数组元素的下标由0开始。
* Shell 数组用括号来表示，元素用"空格"符号分割开，语法格式如下：
  * array_name=(value1 ... valuen)
* 我们也可以使用下标来定义数组:

```sh
array_name[0]=value0
array_name[1]=value1
array_name[2]=value2
```

## 2. 读取数组

* 读取数组元素值的一般格式是：${array_name[index]}

```sh
#!/bin/bash

my_array=(A B "C" D)

echo "第一个元素为: ${my_array[0]}"
echo "第二个元素为: ${my_array[1]}"
echo "第三个元素为: ${my_array[2]}"
echo "第四个元素为: ${my_array[3]}"

#第一个元素为: A
#第二个元素为: B
#第三个元素为: C
#第四个元素为: D
```

* 获取数组中的所有元素,使用@ 或 * 可以获取数组中的所有元素，例如：

```sh
#!/bin/bash

my_array[0]=A
my_array[1]=B
my_array[2]=C
my_array[3]=D

echo "数组的元素为: ${my_array[*]}"
echo "数组的元素为: ${my_array[@]}"
```

* 获取数组长度的方法与获取字符串长度的方法相同，例如：

```sh
#!/bin/bash

my_array[0]=A
my_array[1]=B
my_array[2]=C
my_array[3]=D

echo "数组元素个数为: ${#my_array[*]}"
echo "数组元素个数为: ${#my_array[@]}"
```

# Shell运算符

* Shell 和其他编程语言一样，支持多种运算符，包括：
  * 算数运算符
  * 关系运算符
  * 布尔运算符
  * 字符串运算符
  * 文件测试运算符
* 原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。
* 例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ')：

```sh
#!/bin/bash
val=`expr 2 + 2`
echo "两数之和为 : $val" #两数之和为 : 4
```

* 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。
* 完整的表达式要被 \` \` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。
* centos中可用“$((运算式))”或“$[运算式]”

## 1. 算术运算符

下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：

运算符|说明|举例
---|---|---
+|加法|\`expr \$a + $b\` 结果为 30。
-|减法|\`expr \$a - $b\` 结果为 -10。
*|乘法|\`expr \$a \* $b\` 结果为  200。
/|除法|\`expr \$b / \$a\` 结果为 2。
%|取余|\`expr \$b % \$a\` 结果为 0。
=|赋值|a=$b 将把变量 b 的值赋给 a。
==|相等。用于比较两个数字，相同则返回 true。|[ $a == $b ] 返回 false。
!=|不相等。用于比较两个数字，不相同则返回 true。|[ $a != $b ] 返回 true。
注意：

* 乘号(*)前边必须加反斜杠(\)才能实现乘法运算；
* if...then...fi 是条件语句，后续将会讲解。
* 在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 "*" 不需要转义符号 "\" 。

## 2. 关系运算符

* 关系运算符只支持数字，不支持字符串，除非字符串的值是数字。
* 下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：

运算符|说明|举例
---|---|---
-eq|检测两个数是否相等，相等返回 true。|[ \$a -eq $b ] 返回 false。
-ne|检测两个数是否不相等，不相等返回 true。|[ \$a -ne $b ] 返回 true。
-gt|检测左边的数是否大于右边的，如果是，则返回 true。|[ \$a -gt $b ] 返回 false。
-lt|检测左边的数是否小于右边的，如果是，则返回 true。|[ \$a -lt $b ] 返回 true。
-ge|检测左边的数是否大于等于右边的，如果是，则返回 true。|[\$a -ge $b ] 返回 false。
-le|检测左边的数是否小于等于右边的，如果是，则返回 true。|[ \$a -le $b ] 返回 true。

* 关系运算符实例如下：

```sh
#!/bin/bash
a=10
b=20

if [ $a -eq $b ]
then
   echo "$a -eq $b : a 等于 b"
else
   echo "$a -eq $b: a 不等于 b"
fi
if [ $a -ne $b ]
then
   echo "$a -ne $b: a 不等于 b"
else
   echo "$a -ne $b : a 等于 b"
fi
if [ $a -gt $b ]
then
   echo "$a -gt $b: a 大于 b"
else
   echo "$a -gt $b: a 不大于 b"
fi
if [ $a -lt $b ]
then
   echo "$a -lt $b: a 小于 b"
else
   echo "$a -lt $b: a 不小于 b"
fi
if [ $a -ge $b ]
then
   echo "$a -ge $b: a 大于或等于 b"
else
   echo "$a -ge $b: a 小于 b"
fi
if [ $a -le $b ]
then
   echo "$a -le $b: a 小于或等于 b"
else
   echo "$a -le $b: a 大于 b"
fi
#10 -eq 20: a 不等于 b
#10 -ne 20: a 不等于 b
#10 -gt 20: a 不大于 b
#10 -lt 20: a 小于 b
#10 -ge 20: a 小于 b
#10 -le 20: a 小于或等于 b
```

## 3. 布尔运算符

* 下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：

运算符|说明|举例
---|---|---
!|非运算，表达式为 true 则返回 false，否则返回 true。|[ ! false ] 返回 true。
-o|或运算，有一个表达式为 true 则返回 true。|[ $a -lt 20 -o $b -gt 100 ] 返回 true。
-a|与运算，两个表达式都为 true 才返回 true。|[ $a -lt 20 -a $b -gt 100 ] 返回 false。

* 布尔运算符实例如下：

```sh
#!/bin/bash
a=10
b=20

if [ $a != $b ]
then
   echo "$a != $b : a 不等于 b"
else
   echo "$a == $b: a 等于 b"
fi
if [ $a -lt 100 -a $b -gt 15 ]
then
   echo "$a 小于 100 且 $b 大于 15 : 返回 true"
else
   echo "$a 小于 100 且 $b 大于 15 : 返回 false"
fi
if [ $a -lt 100 -o $b -gt 100 ]
then
   echo "$a 小于 100 或 $b 大于 100 : 返回 true"
else
   echo "$a 小于 100 或 $b 大于 100 : 返回 false"
fi
if [ $a -lt 5 -o $b -gt 100 ]
then
   echo "$a 小于 5 或 $b 大于 100 : 返回 true"
else
   echo "$a 小于 5 或 $b 大于 100 : 返回 false"
fi
#10 != 20 : a 不等于 b
#10 小于 100 且 20 大于 15 : 返回 true
#10 小于 100 或 20 大于 100 : 返回 true
#10 小于 5 或 20 大于 100 : 返回 false
```

## 4. 逻辑运算符

* 以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:

运算符|说明|举例
---|---|---
&&|逻辑的 AND|[[ $a -lt 100 && $b -gt 100 ]] 返回 false
\|\||逻辑的 OR|[[ $a -lt 100 || $b -gt 100 ]] 返回 true

* 逻辑运算符实例如下：

```sh
#!/bin/bash
a=10
b=20

if [[ $a -lt 100 && $b -gt 100 ]]
then
   echo "返回 true"
else
   echo "返回 false"
fi

if [[ $a -lt 100 || $b -gt 100 ]]
then
   echo "返回 true"
else
   echo "返回 false"
fi
# 返回 false
# 返回 true
```

## 5. 字符串运算符

* 下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：

运算符|说明|举例
---|---|---
=|检测两个字符串是否相等，相等返回 true。|[ \$a = $b ] 返回 false。
!=|检测两个字符串是否相等，不相等返回 true。|[ \$a != $b ] 返回 true。
-z|检测字符串长度是否为0，为0返回 true。|[ -z $a ] 返回 false。
-n|检测字符串长度是否为0，不为0返回 true。|[ -n "$a" ] 返回 true。
$|检测字符串是否为空，不为空返回 true。|[ $a ] 返回 true。

* 字符串运算符实例如下：

```sh
#!/bin/bash
a="abc"
b="efg"

if [ $a = $b ]
then
   echo "$a = $b : a 等于 b"
else
   echo "$a = $b: a 不等于 b"
fi
if [ $a != $b ]
then
   echo "$a != $b : a 不等于 b"
else
   echo "$a != $b: a 等于 b"
fi
if [ -z $a ]
then
   echo "-z $a : 字符串长度为 0"
else
   echo "-z $a : 字符串长度不为 0"
fi
if [ -n "$a" ]
then
   echo "-n $a : 字符串长度不为 0"
else
   echo "-n $a : 字符串长度为 0"
fi
if [ $a ]
then
   echo "$a : 字符串不为空"
else
   echo "$a : 字符串为空"
fi

# abc = efg: a 不等于 b
# abc != efg : a 不等于 b
# -z abc : 字符串长度不为 0
# -n abc : 字符串长度不为 0
# abc : 字符串不为空
```

## 6. 文件测试运算符

* 文件测试运算符用于检测 Unix 文件的各种属性。
* 属性检测描述如下：

操作符|说明|举例
---|---|---
-b file|检测文件是否是块设备文件，如果是，则返回 true。|[ -b $file ] 返回 false。
-c file|检测文件是否是字符设备文件，如果是，则返回 true。|[ -c $file ] 返回 false。
-d file|检测文件是否是目录，如果是，则返回 true。|[ -d $file ] 返回 false。
-f file|检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。|[ -f $file ] 返回 true。
-g file|检测文件是否设置了 SGID 位，如果是，则返回 true。|[ -g $file ] 返回 false。
-k file|检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。|[ -k $file ] 返回 false。
-p file|检测文件是否是有名管道，如果是，则返回 true。|[ -p $file ] 返回 false。
-u file|检测文件是否设置了 SUID 位，如果是，则返回 true。|[ -u $file ] 返回 false。
-r file|检测文件是否可读，如果是，则返回 true。|[ -r $file ] 返回 true。
-w file|检测文件是否可写，如果是，则返回 true。|[ -w $file ] 返回 true。
-x file|检测文件是否可执行，如果是，则返回 true。|[ -x $file ] 返回 true。
-s file|检测文件是否为空（文件大小是否大于0），不为空返回 true。|[ -s $file ] 返回 true。
-e file|检测文件（包括目录）是否存在，如果是，则返回 true。|[ -e $file ] 返回 true。
其他检查符：

-S: 判断某文件是否 socket。
-L: 检测文件是否存在并且是一个符号链接。
实例

* 变量 file 表示文件 /var/www/runoob/test.sh，它的大小为 100 字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性：

```sh
#!/bin/bash

file="/var/www/runoob/test.sh"
if [ -r $file ]
then
   echo "文件可读"
else
   echo "文件不可读"
fi
if [ -w $file ]
then
   echo "文件可写"
else
   echo "文件不可写"
fi
if [ -x $file ]
then
   echo "文件可执行"
else
   echo "文件不可执行"
fi
if [ -f $file ]
then
   echo "文件为普通文件"
else
   echo "文件为特殊文件"
fi
if [ -d $file ]
then
   echo "文件是个目录"
else
   echo "文件不是个目录"
fi
if [ -s $file ]
then
   echo "文件不为空"
else
   echo "文件为空"
fi
if [ -e $file ]
then
   echo "文件存在"
else
   echo "文件不存在"
fi
#文件可读
#文件可写
#文件可执行
#文件为普通文件
#文件不是个目录
#文件不为空
#文件存在
```
# Shell打印输出命令

## 1. echo命令

* Shell 的 echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出。命令格式：`echo string`
* 您可以使用echo实现更复杂的输出格式控制。

### 1.1 显示普通字符串

```sh
echo "It is a test"
```

这里的双引号完全可以省略，以下命令与上面实例效果一致：

```sh
echo It is a test
```

### 1.2 显示转义字符

```sh
echo "\"It is a test\""
#结果将是:
#"It is a test"
```

### 1.3 显示变量

* read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量

```sh
#!/bin/sh
read name
echo "$name It is a test"
```

* 以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:

```sh
[root@www ~]# sh test.sh
OK                     #标准输入
OK It is a test        #输出
```

### 1.4 显示换行

```sh
echo -e "OK! \n" # -e 开启转义
echo "It is a test"

# 输出结果：
# OK!
#
# It is a test
```

### 1.5 显示不换行

```sh
#!/bin/sh
echo -e "OK! \c" # -e 开启转义 \c 不换行
echo "It is a test"
# 输出结果：
#
# OK! It is a test
```

### 1.6 显示结果定向至文件

```sh
echo "It is a test" > myfile
```

### 1.7 原样输出字符串，不进行转义或取变量(用单引号)

```sh
echo '$name\"'
#输出结果：
#$name\"
```

### 1.8 显示命令执行结果

```sh
echo `date`
#注意： 这里使用的是反引号 `, 而不是单引号 '。
#结果将显示当前日期
#Thu Jul 24 10:08:46 CST 2014
```

## 2. printf 命令

* printf 命令模仿 C 程序库（library）里的 printf() 程序。
* printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。
* printf 使用引用文本或空格分隔的参数，外面可以在 * printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n。

`printf` 命令的语法：printf  format-string  [arguments...]

* 参数说明：
  * format-string: 为格式控制字符串
  * arguments: 为参数列表。
* 实例如下：

```sh
$ echo "Hello, Shell"
Hello, Shell
$ printf "Hello, Shell\n"
Hello, Shell
```

### 2.1 printf实例

```sh
#!/bin/bash
printf "%-10s %-8s %-4s\n" 姓名 性别 体重kg  
printf "%-10s %-8s %-4.2f\n" 郭靖 男 66.1234
printf "%-10s %-8s %-4.2f\n" 杨过 男 48.6543
printf "%-10s %-8s %-4.2f\n" 郭芙 女 47.9876
```

* 执行脚本，输出结果如下所示：

```txt
姓名     性别   体重kg
郭靖     男      66.12
杨过     男      48.65
郭芙     女      47.99
```

* %s %c %d %f都是格式替代符
  * %-10s 指一个宽度为10个字符
  * -表示左对齐，没有则表示右对齐，任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。
  * %-4.2f 指格式化为小数，其中.2指保留2位小数。

更多实例：

```sh
#!/bin/bash

# format-string为双引号
printf "%d %s\n" 1 "abc"

# 单引号与双引号效果一样
printf '%d %s\n' 1 "abc"

# 没有引号也可以输出
printf %s abcdef

# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用
printf %s abc def

printf "%s\n" abc def

printf "%s %s %s\n" a b c d e f g h i j

# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替
printf "%s and %d \n"
```

执行脚本，输出结果如下所示：

```txt
1 abc
1 abc
abcdefabcdefabc
def
a b c
d e f
g h i
j  
 and 0
```

## 2.2 printf的转义序列

序列|说明
---|---
\a|警告字符，通常为ASCII的BEL字符
\b|后退
\c|抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略
\f|换页（formfeed）
\n|换行
\r|回车（Carriage return）
\t|水平制表符
\v|垂直制表符
\\\\|一个字面上的反斜杠字符
\ddd|表示1到3位数八进制值的字符。仅在格式字符串中有效
\0ddd|表示1到3位的八进制值字符

```sh
$ printf "a string, no processing:<%s>\n" "A\nB"
a string, no processing:<A\nB>

$ printf "a string, no processing:<%b>\n" "A\nB"
a string, no processing:<A
B>

$ printf "www.runoob.com \a"
www.runoob.com $                  #不换行
```

## 3.read读取控制台的输入

* read [选项] (参数)
  * -p：指定读取值时的提示符
  * -t：指定读取值时等待的时间（秒），如果没有在指定的时间内输入，就不再等待了。
* 参数：变量：指定读取值的变量名

# Shelltest命令

Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。

## 1. 数值测试

参数|说明
---|---
-eq|等于则为真
-ne|不等于则为真
-gt|大于则为真
-ge|大于等于则为真
-lt|小于则为真
-le|小于等于则为真

```sh
num1=100
num2=100
if test $[num1] -eq $[num2]
then
    echo '两个数相等！'
else
    echo '两个数不相等！'
fi
#输出结果：
#两个数相等！
```

## 2. 字符串测试

参数|说明
---|---
=|等于则为真
!=|不相等则为真
-z 字符串|字符串的长度为零则为真
-n 字符串|字符串的长度不为零则为真

```sh
num1="ru1noob"
num2="runoob"
if test $num1 = $num2
then
    echo '两个字符串相等!'
else
    echo '两个字符串不相等!'
fi

#输出结果：
#两个字符串不相等!
```

## 3. 文件测试

参数|说明
---|---
-e 文件名|如果文件存在则为真
-r 文件名|如果文件存在且可读则为真
-w 文件名|如果文件存在且可写则为真
-x 文件名|如果文件存在且可执行则为真
-s 文件名|如果文件存在且至少有一个字符则为真
-d 文件名|如果文件存在且为目录则为真
-f 文件名|如果文件存在且为普通文件则为真
-c 文件名|如果文件存在且为字符型特殊文件则为真
-b 文件名|如果文件存在且为块特殊文件则为真

实例演示：

```sh
cd /bin
if test -e ./bash
then
    echo '文件已存在!'
else
    echo '文件不存在!'
fi
# 输出结果：
# 文件已存在!
```

* 另外，Shell还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为："!"最高，"-a"次之，"-o"最低。例如：

```sh
cd sh/bin
if test -e ./notFile -o -e ./bash
then
    echo '至少有一个文件存在!'
else
    echo '两个文件都不存在'
fi
#输出结果：
#至少有一个文件存在!
```

# Shell流程控制

## 1. 判断语句

### 1.1 if判断

* if else-if else 语法格式：

```sh
if condition1
then
    command1
elif condition2
then
    command2
else
    commandN
fi
```

* 或者：

```sh
if [ 条件判断式 ];then

程序

fi
```

* 以下实例判断两个变量是否相等:

```sh
a=10
b=20
if [ $a == $b ]
then
   echo "a 等于 b"
elif [ $a -gt $b ]
then
   echo "a 大于 b"
elif [ $a -lt $b ]
then
   echo "a 小于 b"
else
   echo "没有符合的条件"
fi
# a 小于 b
```

* **`注意：`** 和Java、PHP等语言不一样，sh的流程控制不可为空。如果else分支没有语句执行，就不要写这个else。

### 1.2 case语句

* Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下：

```sh
case 值 in
模式1)
    command1
    command2
    commandN
    ;;
模式2）
    command1
    command2
    commandN
    ;;
esac
```

* case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。
* 取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。
* 下面的脚本提示输入1到4，与每一种模式进行匹配：

```sh
echo '输入 1 到 4 之间的数字:'
echo '你输入的数字为:'
read aNum
case $aNum in
    1)  echo '你选择了 1'
    ;;
    2)  echo '你选择了 2'
    ;;
    3)  echo '你选择了 3'
    ;;
    4)  echo '你选择了 4'
    ;;
    *)  echo '你没有输入 1 到 4 之间的数字'
    ;;
esac
```

* 输入不同的内容，会有不同的结果，例如：

```sh
#输入 1 到 4 之间的数字:
#你输入的数字为:
#3
#你选择了 3
```

## 2. 循环语句

### 2.1 for循环

* for循环一般格式为：

```sh
for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done
```

* 写成一行：

```sh
for var in item1 item2 ... itemN; do command1; command2… done;
```

* 当变量值在列表里，for循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的shell命令和语句。in列表可以包含替换、字符串和文件名。
* in列表是可选的，如果不用它，for循环使用命令行的位置参数。
* 例如，顺序输出当前列表中的数字：

```sh
for loop in 1 2 3 4 5
do
    echo "The value is: $loop"
done
# The value is: 1
# The value is: 2
# The value is: 3
# The value is: 4
# The value is: 5
```

### 2.2 while 语句

* while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：

```sh
while condition
do
    command
done
```

* 以下是一个基本的while循环，测试条件是：如果int小于等于5，那么条件返回真。int从0开始，每次循环处理时，int加1。运行上述脚本，返回数字1到5，然后终止。

```sh
#!/bin/bash
int=1
while(( $int<=5 ))
do
    echo $int
    let "int++"
done
#运行脚本，输出：
# 1
# 2
# 3
# 4
# 5
```

* 以上实例使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量，具体可查阅：[Bash let 命令](https://www.runoob.com/linux/linux-comm-let.html)

### 2.3 until循环

* until 循环执行一系列命令直至条件为 true 时停止。
* until 循环与 while 循环在处理方式上刚好相反。
* 一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。
* until 语法格式:

```sh
until condition
do
    command
done
```

* condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。
* 以下实例我们使用 until 命令来输出 0 ~ 9 的数字：

```sh
#!/bin/bash

a=0

until [ ! $a -lt 10 ]
do
   echo $a
   a=`expr $a + 1`
done
```

### 2.4 跳出循环

* 在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。

#### 2.4.1 break命令

* break命令允许跳出所有循环（终止执行后面的所有循环）。
* 下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令。

```sh
#!/bin/bash
while :
do
    echo -n "输入 1 到 5 之间的数字:"
    read aNum
    case $aNum in
        1|2|3|4|5) echo "你输入的数字为 $aNum!"
        ;;
        *) echo "你输入的数字不是 1 到 5 之间的! 游戏结束"
            break
        ;;
    esac
done
#执行以上代码，输出结果为：
#
#输入 1 到 5 之间的数字:3
#你输入的数字为 3!
#输入 1 到 5 之间的数字:7
#你输入的数字不是 1 到 5 之间的! 游戏结束
```

#### 2.4.2 continue

* continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。
对上面的例子进行修改：

```sh
#!/bin/bash
while :
do
    echo -n "输入 1 到 5 之间的数字: "
    read aNum
    case $aNum in
        1|2|3|4|5) echo "你输入的数字为 $aNum!"
        ;;
        *) echo "你输入的数字不是 1 到 5 之间的!"
            continue
            echo "游戏结束"
        ;;
    esac
done

#运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 echo "游戏结束" 永远不会被执行。
```

# Shell函数

## 1. 自定义函数

linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。

* shell中函数的定义格式如下：

```sh
[ function ] funname [()]

{

    action;

    [return int;]

}
```

* 说明：
    1. 可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。
    2. 参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255

* 下面的例子定义了一个函数并进行调用：

```sh
#!/bin/bash

demoFun(){
    echo "这是我的第一个 shell 函数!"
}
echo "-----函数开始执行-----"
demoFun
echo "-----函数执行完毕-----"

# 输出结果：
# -----函数开始执行-----
# 这是我的第一个 shell 函数!
# -----函数执行完毕-----
```

* 定义一个带有return语句的函数：

```sh
#!/bin/bash

funWithReturn(){
    echo "这个函数会对输入的两个数字进行相加运算..."
    echo "输入第一个数字: "
    read aNum
    echo "输入第二个数字: "
    read anotherNum
    echo "两个数字分别为 $aNum 和 $anotherNum !"
    return $(($aNum+$anotherNum))
}
funWithReturn
echo "输入的两个数字之和为 $? !"
#输出类似下面：
#这个函数会对输入的两个数字进行相加运算...
#输入第一个数字:
#1
#输入第二个数字:
#2
#两个数字分别为 1 和 2 !
#输入的两个数字之和为 3 !

```

* 函数返回值在调用该函数后通过 $? 来获得。
* 注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。

## 2. 函数参数

* 在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数...

带参数的函数示例：

```sh
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

funWithParam(){
    echo "第一个参数为 $1 !"
    echo "第二个参数为 $2 !"
    echo "第十个参数为 $10 !"
    echo "第十个参数为 ${10} !"
    echo "第十一个参数为 ${11} !"
    echo "参数总数有 $# 个!"
    echo "作为一个字符串输出所有参数 $* !"
}
funWithParam 1 2 3 4 5 6 7 8 9 34 73

# 输出结果：
# 第一个参数为 1 !
# 第二个参数为 2 !
# 第十个参数为 10 !
# 第十个参数为 34 !
# 第十一个参数为 73 !
# 参数总数有 11 个!
# 作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !
```

* 注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n>=10时，需要使用${n}来获取参数。
* 另外，还有几个特殊字符用来处理参数：

参数处理|说明
---|---
$#|传递到脚本的参数个数
$*|以一个单字符串显示所有向脚本传递的参数
$$|脚本运行的当前进程ID号
$!|后台运行的最后一个进程的ID号
$@|与$*相同，但是使用时加引号，并在引号中返回每个参数。
$-|显示Shell使用的当前选项，与set命令功能相同。
$?|显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。

## 3. 系统函数

### 3.1 basename

* basename：返回完整路径最后/的部分，常用于获取文件名
* basename [pathname] [suffix]
* basename [string] [suffix]
* basename命令会删掉所有的前缀包括最后一个/
选项：suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉
* dirname：返回完整路径最后/的前面的部分，常用于返回路径部分
* dirname 文件绝对路径：从给定的包含绝对路径的文件名中出去文件名（非目录部分），然后返回剩下的路径（目录部分）
* 反正两个系统函数都不要最后一个/

# Shell输入输出重定向

大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回​​到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。

重定向命令列表如下：

命令|说明
---|---
command > file|将输出重定向到 file。
command < file|将输入重定向到 file。
command >> file|将输出以追加的方式重定向到 file。
n > file|将文件描述符为 n 的文件重定向到 file。
n >> file|将文件描述符为 n 的文件以追加的方式重定向到 file。
n >& m|将输出文件 m 和 n 合并。
n <& m|将输入文件 m 和 n 合并。
<< tag|将开始标记 tag 和结束标记 tag 之间的内容作为输入。
>需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。

## 1. 输出重定向

* 重定向一般通过在命令间插入特定的符号来实现。特别的，这些符号的语法如下所示:

```sh
command1 > file1
```

* 上面这个命令执行command1然后将输出的内容存入file1。
* 注意任何file1内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用>>操作符。

**实例**
执行下面的 who 命令，它将命令的完整的输出重定向在用户文件中(users):

```sh
$who > users
```

* 执行后，并没有在终端输出信息，这是因为输出已被从默认的标准输出设备（终端）重定向到指定的文件。
* 你可以使用 cat 命令查看文件内容：

```sh
$ cat users
_mbsetupuser console  Oct 31 17:35
tianqixin    console  Oct 31 17:35
tianqixin    ttys000  Dec  1 11:33
```

* 输出重定向会覆盖文件内容，请看下面的例子：

```sh
echo "菜鸟教程：www.runoob.com" > users
cat users
菜鸟教程：www.runoob.com
```

* 如果不希望文件内容被覆盖，可以使用 >> 追加到文件末尾，例如：

```sh
$echo "菜鸟教程：www.runoob.com" >> users
$cat users
菜鸟教程：www.runoob.com
菜鸟教程：www.runoob.com
```

## 2. 输入重定向

和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：

```sh
command1 < file1
```

* 这样，本来需要从键盘获取输入的命令会转移到文件读取内容。
* 注意：输出重定向是大于号(>)，输入重定向是小于号(<)。
**实例**
* 接着以上实例，我们需要统计 users 文件的行数,执行以下命令：

```sh
$ wc -l users
       2 users
```

* 也可以将输入重定向到 users 文件：

```sh
$  wc -l < users
       2
```

* 注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。

```sh
command1 < infile > outfile
```

* 同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。

## 3. 重定向深入讲解

* 一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：
    1. 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。
    2. 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。
    3. 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。
* 默认情况下，command > file 将 stdout 重定向到 file，command < file 将stdin 重定向到 file。

* 如果希望 stderr 重定向到 file，可以这样写：

```sh
$command 2 > file
```

* 如果希望 stderr 追加到 file 文件末尾，可以这样写：

```sh
command 2 >> file
```

2 表示标准错误文件(stderr)。

* 如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：

```sh
command > file 2>&1

或者

$command >> file 2>&1
```

* 如果希望对 stdin 和 stdout 都重定向，可以这样写：

```sh
$ command < file1 >file2
command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。
```

## 4. Here Document

* Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。

* 它的基本的形式如下：

```sh
command << delimiter
    document
delimiter
```

* 它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。

**注意：**

* 结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。
* 开始的delimiter前后的空格会被忽略掉。
**实例**
* 在命令行中通过 wc -l 命令计算 Here Document 的行数：

```sh
$ wc -l << EOF
    欢迎来到
    菜鸟教程
    www.runoob.com
EOF
3          # 输出结果为 3 行
```

我们也可以将 Here Document 用在脚本中，例如：

```sh
#!/bin/bash

cat << EOF
欢迎来到
菜鸟教程
www.runoob.com
EOF
```

* 执行以上脚本，输出结果：

```txt
欢迎来到
菜鸟教程
www.runoob.com
/dev/null 文件
```

* 如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：

```sh
$command > /dev/null
```

/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到"禁止输出"的效果。

如果希望屏蔽 stdout 和 stderr，可以这样写：

```sh
$command > /dev/null 2>&1
```

注意：0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。

#Shell 文件包含

和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。

Shell 文件包含的语法格式如下：

```sh
. filename   # 注意点号(.)和文件名中间有一空格

或

source filename
```

**实例**
创建两个 shell 脚本文件。
test1.sh 代码如下：

```sh
#!/bin/bash

url="http://www.runoob.com"
```

test2.sh 代码如下：

```sh
#!/bin/bash

#使用 . 号来引用test1.sh 文件
. ./test1.sh

# 或者使用以下包含文件代码
# source ./test1.sh

echo "菜鸟教程官网地址：$url"
```

* 接下来，我们为 test2.sh 添加可执行权限并执行：

```sh
chmod +x test2.sh
./test2.sh
菜鸟教程官网地址：http://www.runoob.com
```

**注：** 被包含的文件 test1.sh 不需要可执行权限.

```
打开终端：ctrl+alt+t
清屏：ctrl+l
在终端在退出锁定：ctrl+c


目录：又称为文件夹，是包含所有的文件
目录创建规则：
1、大小是256
2、不能包含特殊字符
3、见名知义 
路径：是反应目录和文件的位置
[绝对位置]文件位置：windows：盘符：\文件夹\文件.avi
	 linux: /home/主文件夹/0520/day01/a
	
[相对位置]当前目录所在位置为 0520 ./day01/a 
		day03 ../day01/a

	.\c...\01jibi\biji.txt
	..\c...\01biji\biji.txt

文件：在计算机中一切皆文件 
在windows中区分文件可以通过扩展名来区分 .exe .txt .ppt
在Linux中文件没有扩展名 可以通过颜色区分 也可以通过命令来区分 file 文件名

在Linux中文件分为：
普通文件
目录文件
设备文件   字符设备文件 块设备文件
管道文件
链接文件

文件权限：
读【r】read
写【w】write
执行【x】execute

d rwx rwx rwx 分为三组
d 目录 成为文件类型
第一组：文件的所属用户
第二组：文件的所属组
第三组：其他用户

Linux命令：
格式 ：命令 选项  参数 

帮助：
命令 --help
man 命令

快捷键：
tab 智能补全   如果没有重复的选项 自动补全 如果有重复项 按两下tab 显示列表
↑ ↓ 历史记录 查看之前敲过的命令 关闭后还会提示 但是同时打开两个终端 相互不会提示

常用命令：
ls 【查看文件】
格式：
ls -a 查看所有文件包含隐藏文件
ls -l 以列表形式查看文件，不包含隐藏文件
ls -lh 以列表形式查看文件，不包含隐藏文件 ，按照1024倍数显示{KB MB GB}
ls -all以列表形式查看文件，包含隐藏文件 快捷方式【ll】

通配符：
【*】 匹配任意多个字符【0-256】  a*  一个以上字符 256一下 
【?】 匹配任意一个字符  a？ 两个字符
【[a-z]】 区间法 匹配a到z的所有字符 只能确定一个字符
【[abcde]】 穷举法 权值法 匹配abcde的所有字符 只能确定一个字符

more 分页显示 空格切换页
需要将结果用|管道作为more的输入

切换工作目录：
cd 【切换工作目录】cd 目录
格式：
cd 切换到用户主目录
cd ~ 切换到当前用户的主目录
cd .. 切换到上级目录 
cd .  切换到当前目录
cd -  切换到上一次目录


创建目录：
mkdir 目录名 -p 递归创建
rmdir 目录名  目录一定是空的
rm 文件  -i询问 -r 递归传出


链接：
格式：
ln 源文件 链接文件 硬链接
ln -s 源文件 链接文件 软连接
硬链接文件占磁盘空间 但是删除源文件不会影响硬链接文件
软链接文件不占磁盘空间 但是删除源文件会影响软链接文件

硬链接和拷贝（复制）区别 无论你修改了哪一个链接之后的文件 两个文件都会改变 保持一致  但是拷贝不会
1、改变软链接文件就是相当于间接的改变了源文件
2、查看文件时默认链接数为1 如果有链接一次递增
3、如果创建的软链接文件和源文件在不同的目录下，需要使用绝对路径


文本搜索：
grep  '搜索内容' 文件名
-n 显示行号
-v 反选
-i 忽略大小写

通配符：
【^a】以a为起始的字符搜索文件
【a$】以a为结尾的字符搜索文件
【.】 配匹任意一个非换行的字符
【*】匹配任意字符（大于0的整数）

文件搜索：
find 目录 参数 文件名（可以使用通配符）
-name 文件名
-size 大小
-perm rwx


归档：
tar -cvf 归档文件名.tar 文件1 文件2  目录1 目录2
解归档：
tar -xvf 归档文件名.tar  -C 路径
 
压缩：
gzip 归档文件名.tar  生成了一个文件 归档文件名.tar.gz 文件大小小于归档文件大小 归档文件名.tar不存在了
解压缩：
gzip -d 归档文件名.tar.gz 生成了一个文件 归档文件名.tar


一步归档压缩：
tar -czvf 文件名.tar.gz 文件1 文件2 目录1 目录2

一步解归档压缩：
tar -xzvf 文件名.tar.gz -C 路径

bzip2压缩：
tar -cjvf 文件名.tar.bz2 文件1 文件2 目录1 目录2
bzip2解压缩：
tar -xjvf 文件名.tar.bz2 -C 路径

zip压缩：
zip 文件名 文件1 文件2 目录1 目录2  生成一个文件为：文件名.zip
unzip解压缩：
unzip 文件名.zip -C 路径



