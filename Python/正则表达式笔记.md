正则表达式笔记
==============

[元字符](#元字符)

   [重复限定符](#重复限定符)

   [分组](#分组)

   [转义](#转义)

   [条件或](#条件或)

   [区间](#区间)
  
[零宽度断言-前后预查](#零宽度断言-前后预查)

[标志](#标志)

[贪婪匹配与惰性匹配](#贪婪匹配与惰性匹配)

[优先级](#优先级)

# 元字符 

元字符|说明
---|---
.|匹配除换行符以外的任意字符
\w|匹配字母或数字或下划线或汉字
\W|匹配所有非字母数字，即符号
\s|匹配任意的空白符
\S|匹配所有非空格字符
\d|匹配数字
\D|匹配非数字
\b|匹配单词的开始或结束
\f|匹配一个换页符
\n|匹配一个换行符
\r|匹配一个回车符
^|匹配字符串的开始
$|匹配字符串的结束

有了元字符之后，我们就可以利用这些元字符来写一些简单的正则表达式了，比如：

匹配有abc开头的字符串：

    \babc或者^abc复制代码

匹配8位数字的QQ号码：

    ^\d\d\d\d\d\d\d\d$复制代码

匹配1开头11位数字的手机号码：

    ^1\d\d\d\d\d\d\d\d\d\d$复制代码

# 重复限定符

语法|说明
---|---
*|重复零次或更多次
+|重复一次或更多次
?|重复零次或一次
{n}|重复n次
{n,}|重复n次或更多次
{n,m}|重复n到m次

有了这些限定符之后，我们就可以对之前的正则表达式进行改造了，比如：

匹配8位数字的QQ号码：

    ^\d{8}$复制代码

匹配1开头11位数字的手机号码：

    ^1\d{10}$复制代码

匹配银行卡号是14~18位的数字：

    ^\d{14,18}$复制代码

匹配以a开头的，0个或多个b结尾的字符串

    ^ab*$复制代码

# 分组 

从上面的例子中看到，*限定符是作用在与他左边最近的一个字符，那么问题来了，如果我想要ab同时被*限定那怎么办呢？

正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。

因此当我们要匹配多个ab时，我们可以这样如：匹配字符串中包含0到多个ab开头：

    ^(ab)*复制代码

# 转义

我们看到正则表达式用小括号来做分组，那么问题来了：

如果要匹配的字符串中本身就包含小括号，那是不是冲突？应该怎么办？

针对这种情况，正则提供了转义的方式，也就是要把这些元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是\即可。如：要匹配以(ab)开头：
    
    ^(\(ab\))*复制代码

# 条件或 

正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。

那么我们就可以用或条件来处理这个问题

    ^(130|131|132|155|156|185|186|145|176)\d{8}$复制代码

# 区间 

[ ]	字符种类。匹配方括号内的任意字符。

[^ ]	否定的字符种类。匹配除了方括号里的任意字符

  正定A-Z 写成[A-Z]
  限定某些数字 [165]
  
例子：

    ^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$

# 零宽度断言-前后预查

先行断言和后发断言都属于非捕获簇（不捕获文本 ，也不针对组合计进行计数）。 先行断言用于判断所匹配的格式是否在另一个确定的格式之前，匹配结果不包含该确定格式（仅作为约束）。

零宽度断言如下：

符号|描述
--|--
(?=...)|正先行断言-存在
(?!...)|负先行断言-排除
(?<=...)|正后发断言-存在
(?<!...)|负后发断言-排除

"(T|t)he(?=\sfat)" => [The](#) fat cat sat on the mat.

正后发断言 记作(?<=...) 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。 例如，表达式 (?<=(T|t)he\s)(fat|mat) 匹配 fat 和 mat，且其前跟着 The 或 the。

"(?<=(T|t)he\s)(fat|mat)" => The fat cat sat on the mat.

# 标志

标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。 这些标志可以任意的组合使用，它也是整个正则表达式的一部分。

标志|描述
--|--
i|忽略大小写。
g|全局搜索。
m|多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。

    "The" => [The](#) fat cat sat on the mat.

    "/The/gi" => [The](#) fat cat sat on [the](#) mat.

# 贪婪匹配与惰性匹配

* 和 + 限定符默认采用贪婪匹配模式，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配。

"/(.*at)/" => [The fat cat sat on the mat](#). 
    
"/(.*?at)/" => [The fat](#) cat sat on the mat. 

# 优先级

运算符|描述
--|--
\\ |转义符
(), (?:), (?=), []|圆括号和方括号
*, +, ?, {n}, {n,}, {n,m}|限定符
^, $, \任何元字符、任何字符|定位点和序列（即：位置和顺序）
\||替换，"或"操作字符具有高于替换运算符的优先级，使得"m|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m|f)ood"。
